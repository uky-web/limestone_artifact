{"version":3,"sources":["project.scss","includes/root-rhythm/_rr-baseline.scss","project.css","includes/root-rhythm/_rr-util.scss"],"names":[],"mappings":"AAwBA;ECoBE,gBA8BmB;EA7BnB,kBAAA;EDnBA,mBAAA;CEtBD;ACmEG;EH/CJ;ICoBE,gBA8BmB;IA7BnB,kBAAA;GCpCC;CACF;;AFmBD;EACE,0BAAA;CEhBD","file":"project.css","sourcesContent":["@use 'includes/root-rhythm';\n@use 'includes/color-functions';\n@use 'tokens/typography';\n// susy is a grid layout tool. This is used when grid or flexbox choices aren't appropriate\n// sshttp: //oddbird.net/susy/\n// @import 'susy';\n\n// mathsass exposes Javascript's Math class to sass. We are using a NewCity fork so we can provide trivial updates\n// https: //github.com/newcity/eyeglass-math/\n// @import 'math';\n\n// mq is a sass/media-query library\n// https://github.com/sass-mq/sass-mq\n// @import 'sass-mq';\n\n\n@import 'includes/rem';\n@import 'includes/math';\n// @import 'includes/colors';\n@import 'includes/variables';\n@import 'includes/mixins';\n\n@import 'includes/design-variables';\n\n:root {\n  @include root-rhythm.rr-font-compute(r, tight, typography.$fonts, typography.$lineheights);\n  position: relative;\n}\n\nbody {\n  background-color: color-functions.color(wildcat-blue);\n}","@use \"rr-config\" as *;\n@use \"rr-grid\" as *;\n@use \"rr-util\" as *;\n\n\n// Render the columns as a repeating linear gradient.\n@function rr-columns($break: s) {\n  $gutter: rr-prop-for-breakpoint($break, gutter);\n  $color: rr-prop-for-breakpoint($break, column_color);\n  $columns: rr-prop-for-breakpoint($break, columns);\n  $colwidth: calc(100% / $columns);\n  @if not $color {\n    $color: rgba(0, 0, 0, .5);\n  }\n  @return repeating-linear-gradient(to left, transparent 0, transparent $gutter, $color $gutter, $color $colwidth);\n}\n\n// Render the baselines as a simple linear gradient. This gradient has \n// small enough values that Safari goes batshit if you try to do it with a \n// repeating linear gradient. \n@function rr-baselines($break: s) {\n  $baseline: rr-gridbase();\n  $color: rr-prop-for-breakpoint($break, baseline_color);\n  @if not $color {\n    $color: rgba(0, 0, 0, .5);\n  }\n  @return linear-gradient(to top, #{$color} 0, #{$color} 1px, transparent 1px, transparent 100%);\n}\n\n// Pass a fontsize and how many grid-spaces of spacing you want around it,\n// and this will return font size and line-height declarations. Line-heights\n// are sent back with a unit (instead of unitless) in an attempt to keep \n// the grid a little more bullet-proof. \n//\n// If you want smaller line-height than the font size, you can pass negative \n// values.\n//\n// If you want a line height close to 1, make sure the font size is a multiple\n// of the grid base and `$steps` is 0.\n@mixin rr-font-line-height($fontsize, $steps: 0) {\n  // Our grid unit\n  $gridbase: rr-gridbase(); // Match to the font size\n  $container: ceil(calc($fontsize / $gridbase)) * $gridbase; // Add the offset value to the text\n  $leading: $steps * $gridbase;\n  font-size: $fontsize;\n  line-height: $container + $leading;\n}\n\n// Extract all the possible font sizes out of a font size config. \n// this is more complicated than your typical keywords() op because\n// font config is organized by breakpoint, then size.\n@function rr-font-sizes($font-config: $rr-fonts) {\n  $working-map: ();\n  @each $break, $fontmap in $font-config {\n    $working-map: map-merge($working-map, $fontmap);\n  }\n\n  \n  @return map-keys($working-map);\n}\n\n\n// Pass a font tag and a lineheight tag and rr-font-config returns font size and\n// line height properties for each breakpoint.\n@mixin rr-font-compute($size: m, $lineheight: medium, $font-config: $rr-fonts, $lineheight-config: $rr-lineheights) {\n\n  $breaks: rr-breakpoint-list();\n\n  $linegridheight: map-get($lineheight-config, $lineheight);\n  @each $break in $breaks {\n    @if map-has-key($font-config, $break) { //only s and l pass this, bc that's all in rr-fonts\n      $font-size-set: map-get($font-config, $break);\n      @if map-has-key($font-size-set, $size) {\n        @include rr-break-directive($break) {\n          $fontsize: map-get($font-size-set, $size);\n          @include rr-font-line-height($fontsize, $linegridheight);\n        }\n      } \n    } \n  }\n}\n// Builds a list of style rules with the specified prefix, size tag, and\n// lineheight tag. Useful for building pattern libraries or if you intend\n// to expose design capabilities through css.\n@mixin rr-font-samples($prefix: 'text', $font-config, $lineheight-config) {\n  $font-sizes: rr-font-sizes($font-config);\n  @each $fs in $font-sizes {\n    @each $name, $size in $fs {\n      @each $linename, $lineheight in $lineheight-config {\n        .#{$prefix}-#{$name}-#{$linename} {\n          background-color: rgba(200, 255, 200, .3);\n          @include rr-font-compute($name, $linename,$font-config, $lineheight-config);\n        }\n      }\n    }\n  }\n}\n\n// Builds basic heading layout using the heading style configuration, including\n// media queries.\n@mixin rr-heading($config-map-tag, $heading-config, $font-config, $lineheight-config) {\n  @if map-has-key($heading-config, $config-map-tag) {\n    $config: map-get($map: $heading-config, $key: $config-map-tag);\n    $size: m;\n    @if map-has-key($config, size) {\n      $size: map-get($config, size);\n    }\n    $lineheight: medium;\n    @if map-has-key($config, lineheight) {\n      $lineheight: map-get($config, lineheight);\n    }\n    @include rr-font-compute($size, $lineheight, $font-config, $lineheight-config);\n    $font: sans-serif;\n    @if map-has-key($config, font) {\n      $font: map-get($config, font);\n    }\n    font-family: $font;\n    @if map-has-key($config, weight) {\n      font-weight: map-get($config, weight);\n    }\n    @if map-has-key($config, style) {\n      font-style: map-get($config, style);\n    }\n  }\n}\n\n// Add columns to a ::before pseudoelement, gridlines to an ::after pseudoelement.\n@mixin rr-grid-overlay {\n  &::before {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    max-width: $rr-maxwidth;\n    min-height: 100vh;\n    margin-right: auto;\n    margin-left: auto;\n    content: '';\n    z-index: 1000;\n    pointer-events: none;\n    mix-blend-mode: $rr-blend-mode;\n    $breaks: rr-breakpoint-list();\n    @each $break in $breaks {\n      $offset: rr-prop-for-breakpoint($break, offset);\n      $gutter: rr-prop-for-breakpoint($break, gutter);\n      $cols: rr-prop-for-breakpoint($break, columns);\n      @include rr-break-directive($break) {\n        @if $offset > 0 {\n          width: calc(100% - (2 * #{$offset}));\n        } @else {\n          width: 100%;\n        }\n        background-image: rr-columns($break);\n        background-size: calc(100% + #{$gutter});\n      }\n    }\n  }\n\n  &::after {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    min-height: 100vh;\n    margin-right: auto;\n    margin-left: auto;\n    content: '';\n    z-index: 1000;\n    pointer-events: none;\n    mix-blend-mode: $rr-blend-mode;\n    $breaks: rr-breakpoint-list();\n    @each $break in $breaks {\n      @include rr-break-directive($break) {\n        background: transparent rr-baselines($break) scroll repeat left top / 100% rr-gridbase();\n      }\n    }\n  }\n}\n",":root {\n  font-size: 1rem;\n  line-height: 1rem;\n  position: relative;\n}\n@media screen and (min-width: 76rem) {\n  :root {\n    font-size: 1rem;\n    line-height: 1rem;\n  }\n}\n\nbody {\n  background-color: #0033a0;\n}","@use \"../../tokens/layout\";\n@use \"rr-config\" as *;\n\n// Gets the list of breakpoints; very useful for walking\n// the configuration.\n@function rr-breakpoint-list($config: layout.$rr-grid-settings) {\n  @return map-keys($config);\n}\n\n// Return a breakpoint configuration for the specified tag. \n// The tag is the first-level value in the `$rr-grid-settings` map.\n// This does not compute mobile-first cascade; you need to \n// use `$rr-combined-breakpoint` instead. \n@function rr-breakpoint($tag) {\n  $config: layout.$rr-grid-settings;\n  @if map-has-key($config, $tag) {\n    @return map-get($config, $tag);\n  } @else {\n    @return map-get($config, nth(map-keys($config), 1));\n  }\n}\n\n@function rr-first-breakpoint($break, $config: layout.$rr-grid-settings) {\n  $breaks: rr-breakpoint-list($config);\n  @return $break == nth($breaks, 1);\n}\n\n// Returns the first breakpoint config settings.\n// Remember maps are 1-indexed.\n@function rr-breakpoint-first() {\n  @return rr-breakpoint(nth(rr-breakpoint-list(), 1));\n}\n\n// Compute the size of a grid square, computed in the unit of the\n// line height. You can pass an optional multiplier.\n@function rr-gridbase($multiplier: 1) {\n  @return (calc($rr-line-height / layout.$rr-grid-divisions)) * $multiplier;\n}\n\n// deprecated\n@function rr-grid-units($steps) {\n  @return rr-gridbase($steps);\n}\n\n// Takes an offset value (like the width of a border) and a number of \n// grid steps; returns the size of the remaining grid step area.\n// Useful primarily for adding borders around things. \n@function rr-grid-remainder($offset, $steps: 1) {\n  $result: 0;\n  @if $steps < 1 {\n    $result: 0;\n  } @else {\n    $stepsize: rr-gridbase($steps);\n    @if comparable($offset, $stepsize) {\n      $result: $stepsize - $offset;\n    } @else {\n      $result: calc(#{$stepsize} - #{$offset});\n    }\n  }\n  @return $result;\n}\n\n// Convenience mixin for building breakpoints around the media queries. \n@mixin rr-break-directive($break, $config: layout.$rr-grid-settings) {\n  @if rr-first-breakpoint($break, $config) {\n    // Base Breakpoint\n    @content;\n    // End base breakpoint\n  } @else {\n    $mq: rr-prop-for-breakpoint($break, mq);\n    $size: rr-prop-for-breakpoint($break, size);\n    @media screen and ($mq: $size) {\n      @content;\n    }\n  }\n}\n\n// Return a breakpoint configuration for the specified tag. \n// The tag is the first-level value in the `$rr-grid-settings` map. \n// Unlike `rr-breakpoint`, this will look up values from earlier \n// breakpoints. \n@function rr-combined-breakpoint($break: s) {\n  $breaks: rr-breakpoint-list();\n  $work-map: rr-breakpoint-first();\n  $stop: index($breaks, $break);\n  @if not $stop {\n    @return $work-map;\n  } // Bounds-check the stop\n  @if ($stop > 1) {\n    @for $i from 2 through $stop {\n      $tag: nth($breaks, $i);\n      $work-map: map-merge($work-map, rr-breakpoint($tag));\n    }\n  }\n  @return $work-map;\n}\n\n// Given a breakpoint tag and a property name, return the property value. \n// This looks for the property in the combined breakpoint.\n@function rr-prop-for-breakpoint($break, $prop) {\n  $bp: rr-combined-breakpoint($break);\n  @if map-has-key($bp, $prop) {\n    @return map-get($bp, $prop);\n  }\n  @return null;\n}\n\n// Given a breakpoint tag and a property name, return the property value. \n// This looks for the property only in the specified breakpoint.\n@function rr-strict-prop-for-breakpoint($break, $prop) {\n  $bp: rr-breakpoint($break);\n  @if map-has-key($bp, $prop) {\n    @return map-get($bp, $prop);\n  }\n  @return null;\n}\n"]}